包sync实现了两种类型的锁： sync.Mutex （互拆锁） 和 sync.RWMutex。(读，写互拆锁)

Mutex 是同步基元，它只向一个线程授予对共享资源的独占访问权。
一个零值的互斥锁表示它没有锁住
如果一个线程获取了互斥体，则要获取该互斥体的第二个线程将被挂起，直到第一个线程释放该互斥体。
某一方法在运行中，有并发访问上来，会排队。所谓排队就是顺序的一个一个的依次执行。这就是同步锁

互斥锁和goroutine是不关联的，就是说一个goroutine对一个锁加锁后，可以由另一个goroutine解锁。


互斥锁类似比喻：流水线上，A和B两个人（两个线程）加工某零件（全局变量）,一共分两个步骤，A要完成步骤1才能由B完成步骤2，
当A要加工时会喊一声“我要加工这个零件了”（申请加锁并成功加锁）,然后开始加工。
而B要加工零件时，也会喊一声（申请加锁），被告知A正在处理步骤1,B只能等待A处理完并喊“我处理完了”，B才能继续。
这样保持了正常的加工顺序。

对于任意 sync.Mutex 或 sync.RWMutex 变量l。 如果 n < m ，那么第n次 l.Unlock() 调用在第 m次 l.Lock() 调用返回前发生。

例如程序：

  var l sync.Mutex
  var a string
  
  func f() {
          a = "hello, world";
          l.Unlock();
  }
  
  func main() {
          l.Lock(); //main Lock ，下面的函数按顺序，一个一个执行
          go f(); //解锁了
          l.Lock();// 开始调用 Lock, 
                   // 在 LOCK 返回之前调用Unlock     
          print(a);// 在锁上之前，调用了。()
  }
可以确保输出“hello, world”结果。因为，
第一次 l.Unlock() 调用（在f函数中）在第二次 l.Lock() 调用 （在main 函数中）返回之前发生，
也就是在 print 函数调用之前发生。
