反射的规则
在运行时反射是程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。

类型和接口
由于反射构建于类型系统之上，就从复习一下 Go 中的类型开始吧。

Go 是静态类型的。每一个变量有一个静态的类型，也就是说，有一个已知类型并且在编译时就确定下来了：
int，float32，*MyType，[]byte 等等。如果定义

type MyInt int 
var i int 
var j MyInt 

那么 i 的类型为 int 而 j 的类型为 MyInt。即使变量 i 和 j 有相同的底层类型，它们仍然是有不同的静态类型的。
未经转换是不能相互赋值的。

在类型中有一个重要的类别就是接口类型，表达了固定的一个方法集合
。一个接口变量可以存储任意实际值（非接口），只要这个值实现了接口的方法。

众所周知的一个例子就是 is io.Reader 和 io.Writer，来自 io 包的类型 Reader 和 Writer：

// Reader 是包裹了基础的 Read 方法的接口。.
type Reader interface {    
     Read(p []byte) (n int, err os.Error)
     }  // Writer 是包裹了基础 Write 方法的接口。

type Writer interface {
         Write(p []byte) (n int, err os.Error) 
} 
任何用这个声明实现了 Read（或 Write）方法的类型，可以说它实现了 io.Reader（或 io.Writer）。
基于本讨论来说，这意味着 io.Reader 类型的变量可以保存任意值，只要这个值的类型实现了 Read 方法：

var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer) // 等等 
有一个事情是一定要明确的，不论 r 保存了什么值，r 的类型总是 io.Reader：Go 是静态类型，而 r 的静态类型是 io.Reader。

接口类型的一个极端重要的例子是空接口：

interface{} 
它表示空的方法集合，由于任何值都有另个或者多个方法，所以任何值都可以满足它。

也有人说 Go 的接口是动态类型的，不过这是一种误解。它们是静态类型的：接口类型的变量总是有着相同的静态类型，
这个值总是满足空接口，只是存储在接口变量中的值运行时也有可能被改变类型。

对于所有这些都必须严谨的对待，因为反射和接口密切相关。




