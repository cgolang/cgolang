反射的规则
在运行时反射是程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。

类型和接口
由于反射构建于类型系统之上，就从复习一下 Go 中的类型开始吧。

Go 是静态类型的。每一个变量有一个静态的类型，也就是说，有一个已知类型并且在编译时就确定下来了：
int，float32，*MyType，[]byte 等等。如果定义

type MyInt int 
var i int 
var j MyInt 

那么 i 的类型为 int 而 j 的类型为 MyInt。即使变量 i 和 j 有相同的底层类型，它们仍然是有不同的静态类型的。
未经转换是不能相互赋值的。

在类型中有一个重要的类别就是接口类型，表达了固定的一个方法集合
。一个接口变量可以存储任意实际值（非接口），只要这个值实现了接口的方法。

众所周知的一个例子就是 is io.Reader 和 io.Writer，来自 io 包的类型 Reader 和 Writer：

// Reader 是包裹了基础的 Read 方法的接口。.
type Reader interface {    
     Read(p []byte) (n int, err os.Error)
     }  // Writer 是包裹了基础 Write 方法的接口。

type Writer interface {
         Write(p []byte) (n int, err os.Error) 
} 
任何用这个声明实现了 Read（或 Write）方法的类型，可以说它实现了 io.Reader（或 io.Writer）。
基于本讨论来说，这意味着 io.Reader 类型的变量可以保存任意值，只要这个值的类型实现了 Read 方法：

var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer) // 等等 
有一个事情是一定要明确的，不论 r 保存了什么值，r 的类型总是 io.Reader：Go 是静态类型，而 r 的静态类型是 io.Reader。

接口类型的一个极端重要的例子是空接口：

interface{} 
它表示空的方法集合，由于任何值都有另个或者多个方法，所以任何值都可以满足它。

也有人说 Go 的接口是动态类型的，不过这是一种误解。它们是静态类型的：接口类型的变量总是有着相同的静态类型，
这个值总是满足空接口，只是存储在接口变量中的值运行时也有可能被改变类型。

对于所有这些都必须严谨的对待，因为反射和接口密切相关。



接口类型的变量存储了两个内容：赋值给变量实际的值和这个值的类型描述。
更准确的说，值是底层实现了接口的实际数据项目，而类型描述了这个项目完整的类型。例如下面，

var r io.Reader 
tty, err = os.OpenFile("/dev/tty", os.O_RDWR, 0) 
      if err != nil { 
            return nil, err 
} 
r = tty 

用模式的形式来表达 r 包含了的是 (value, type) 
对，如 (tty, *os.File)。注意类型 *os.File 除了 Read 方法还实现了其他方法：
尽管接口值仅仅提供了访问 Read 方法的可能，但是内部包含了这个值的完整的类型信息。这也就是为什么可以这样做：

var w io.Writer

w ，ok = r.(io.Writer) // test whether r implements "io.Writer.Read()"  

r.(io.Writer) 类型断言：判断r 的类型 是不是满足 io.writer 接口，如果满足，w将对应转换后的
 io.Writer 类型

在这个赋值中的断言是一个类型断言：它断言了 r 内部的条目同时也实现了 io.Writer，
因此可以赋值它到 w。在赋值之后，w 将会包含 (tty, *os.File)。
跟在 r 中保存的一致。接口的静态类型决定了哪个方法可以通过接口变量调用，
即便内部实际的值可能有一个更大的方法集。

接下来，可以这样做：

var empty interface{} 
empty = w 
而空接口值 e 也将包含同样的 (tty, *os.File)。
这很方便：空接口可以保存任何值同时保留关于那个值的所有信息。

（这里无需类型断言，因为 w 是肯定满足空接口的。
在这个例子中，将一个值从 Reader 变为 Writer，由于 Writer 的方法不是 Reader 的子集，所以就必须明确使用类型断言。）
一个很重要的细节是接口内部的对总是 (value, 实际类型) 的格式，而不会有 (value, 接口类型) 的格式。接口不能保存接口值。
现在准备好来反射了。



